import{_ as e,o as a,c as s,V as n}from"./chunks/framework.c5c8a48b.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"2023/webgl学习/thre0e0.jsde0yuan2ma3.md","filePath":"2023/webgl学习/thre0e0.jsde0yuan2ma3.md","lastUpdated":null}'),r={name:"2023/webgl学习/thre0e0.jsde0yuan2ma3.md"},t=n('<p>在一个最简单的three.js案例中，我们需要有场景(scene)、相机(camera)、渲染器(WebGLRenderer)。</p><h3 id="scene" tabindex="-1">scene： <a class="header-anchor" href="#scene" aria-label="Permalink to &quot;scene：&quot;">​</a></h3><p>源码路径：src\\scenes\\Scene.js 发现scene类其实比较简单，它继承自Object3D类，接下来继续去看看Object3D，源码路径：src\\core\\Object3D.js；发现 Object3D 又继承自 EventDispatcher ，接着看：src\\core\\EventDispatcher.js。</p><p>EventDispatcher类封装了事件的监听处理，包含四个函数：addEventListener（添加事件监听）、hasEventListener（判断事件监听是否已经存在）、removeEventListener（移除事件监听）、dispatchEvent（事件监听调度）</p><p>在scene的add方法中，设置了scene的children和添加的Object3D的parent属性。</p><h3 id="camera" tabindex="-1">camera <a class="header-anchor" href="#camera" aria-label="Permalink to &quot;camera&quot;">​</a></h3><p>这里看的是透视相机 PerspectiveCamera ，源码路径：src\\cameras\\PerspectiveCamera.js，PerspectiveCamera 继承自 Camera ，src\\cameras\\Camera.js，发现Camera类也是继承自Object3D。在Camera的构造函数中，对各种矩阵进行了初始化操作，在 PerspectiveCamera 的构造函数中，调用了 updateProjectionMatrix方法，这个方法会根据透视相机构造参数进行矩阵更新。</p><h3 id="webglrenderer" tabindex="-1">WebGLRenderer <a class="header-anchor" href="#webglrenderer" aria-label="Permalink to &quot;WebGLRenderer&quot;">​</a></h3><p>源码路径：src\\renderers\\WebGLRenderer.js，妈的，一个构造函数两千多行，不想看了。在webGLRenderer的源码中看到了这一行，所以用three.js构建的canvas上，会有data-engine属性。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> ( </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">setAttribute</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">in</span><span style="color:#A6ACCD;"> canvas ) canvas</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setAttribute</span><span style="color:#A6ACCD;">( </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">data-engine</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">`</span><span style="color:#C3E88D;">three.js r</span><span style="color:#89DDFF;">${</span><span style="color:#A6ACCD;">REVISION</span><span style="color:#89DDFF;">}`</span><span style="color:#A6ACCD;"> )</span></span></code></pre></div><p>在webGLRenderer的源码中还会做XR的相关处理，而 WebXRManager 这个类的构造函数又是八百多行，是一个比较复杂的类，这些逻辑对于cad来说其实是完全多余的。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> xr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">WebXRManager</span><span style="color:#A6ACCD;">( _this</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> _gl )</span></span>\n<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">xr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> xr</span></span></code></pre></div><p>在webGLRenderer的源码中很多方法都是直接挂载到this上面，这就导致了很多方法根据不会被使用，却需要花费内存来创建。更好的方式可能是实现按需导入，这样打包的时候会就可以Tree-Shaking掉那些并没有用到的方法。</p><h3 id="webglrenderer的render方法" tabindex="-1">WebGLRenderer的render方法 <a class="header-anchor" href="#webglrenderer的render方法" aria-label="Permalink to &quot;WebGLRenderer的render方法&quot;">​</a></h3><p>影响图纸加载卡顿的关系就是render方法的执行时间，在WebGLRenderer的源码src\\renderers\\WebGLRenderer.js中，render方法的代码并不算很多，只有一百多行。根本看不懂！</p><p>我问chatgpt，它说： render方法的目标是在WebGL上下文中呈现场景和相机，将3D对象渲染到屏幕上。该方法通常包含以下步骤：</p><ul><li>检查渲染器的参数、状态和场景数据的完整性以及各个变量的有效性。</li><li>准备渲染前的工作，如清除缓冲区、设置渲染目标（如屏幕或纹理）、设置视口、设置渲染器的渲染状态等。</li><li>更新相机的投影矩阵和视图矩阵，以便将场景中的对象正确地显示在相机的视野中。</li><li>对场景中的每个可见对象进行循环迭代，并针对每个对象进行必要的计算和渲染操作。</li><li>根据对象的材质、纹理、光照、阴影等属性，设置相应的WebGL着色器程序以实现物体的渲染。</li><li>将物体的几何数据（顶点位置、法线、纹理坐标等）传递给绑定的着色器程序。</li><li>执行WebGL绘制调用，将几何数据发送到GPU进行渲染。</li><li>根据需要，执行后期处理操作，如应用后期特效、渲染到纹理等。</li><li>恢复渲染状态和缓冲区，以备下一帧绘制。</li></ul><p>cad中没有光照，也没有纹理、阴影、后期特效这些，甚至连旋转矩阵都用不上，cad只需要最基础的平移和缩放操作即可。</p>',18),l=[t];function p(c,o,i,d,D,h){return a(),s("div",null,l)}const b=e(r,[["render",p]]);export{y as __pageData,b as default};
