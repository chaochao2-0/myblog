import{_ as e,o as a,c as t,V as l}from"./chunks/framework.c5c8a48b.js";const u=JSON.parse('{"title":"嘉立创","description":"","frontmatter":{},"headers":[],"relativePath":"速记/we0bgl.md","filePath":"速记/we0bgl.md","lastUpdated":null}'),r={name:"速记/we0bgl.md"},i=l('<h1 id="嘉立创" tabindex="-1">嘉立创 <a class="header-anchor" href="#嘉立创" aria-label="Permalink to &quot;嘉立创&quot;">​</a></h1><h2 id="顶点着色器是不是只有顶点信息-法线这些如何获取" tabindex="-1">顶点着色器是不是只有顶点信息？法线这些如何获取？ <a class="header-anchor" href="#顶点着色器是不是只有顶点信息-法线这些如何获取" aria-label="Permalink to &quot;顶点着色器是不是只有顶点信息？法线这些如何获取？&quot;">​</a></h2><p>不是的，除了顶点信息，顶点着色器还可以访问其他类型的数据，如：法线、纹理坐标等。</p><h2 id="webgl的渲染管线它的流程是怎样的" tabindex="-1">webgl的渲染管线它的流程是怎样的？ <a class="header-anchor" href="#webgl的渲染管线它的流程是怎样的" aria-label="Permalink to &quot;webgl的渲染管线它的流程是怎样的？&quot;">​</a></h2><ul><li>顶点着色器阶段（Vertex Shader Stage）：在这个阶段，输入的顶点数据会被处理。顶点着色器会对每个顶点执行一系列运算，例如计算变换后的顶点位置、法线、纹理坐标等等。这个阶段的输出会被送到下一个阶段进行处理。</li><li>图元装配阶段（Primitive Assembly Stage）：这个阶段会将顶点着色器输出的顶点连接起来，形成几何图形，例如点、线段、三角形等。这个阶段的输出会被送到下一个阶段进行处理。</li><li>光栅化阶段（Rasterization Stage）：在这个阶段，图元会被分解成一组更小的像素，也就是所谓的片元（fragment）。每个片元都有自己的属性，例如颜色、深度值等，这些属性会根据光栅化的结果进行计算。</li><li>片元着色器阶段（Fragment Shader Stage）：在这个阶段，片元的属性会被处理。片元着色器会执行一系列运算，例如计算最终的颜色、混合多个纹理、进行雾效处理等等。这个阶段的输出会被送到下一个阶段进行处理。</li><li>输出合并阶段（Output Merging Stage）：在这个阶段，所有的片元会被送入帧缓冲区，最终生成显示在屏幕上的图像。 需要注意的是，以上只是一个通用的渲染管线流程，具体的实现可能会有所不同。此外，不同的WebGL API版本可能也会有一些差异。</li></ul><h2 id="gltf格式的数据格式是怎样的-如何优化" tabindex="-1">gltf格式的数据格式是怎样的？如何优化？ <a class="header-anchor" href="#gltf格式的数据格式是怎样的-如何优化" aria-label="Permalink to &quot;gltf格式的数据格式是怎样的？如何优化？&quot;">​</a></h2>',6),o=[i];function n(s,d,h,c,_,g){return a(),t("div",null,o)}const f=e(r,[["render",n]]);export{u as __pageData,f as default};
