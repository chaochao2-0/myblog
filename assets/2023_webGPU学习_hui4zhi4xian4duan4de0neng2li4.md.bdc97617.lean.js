import{_ as t,o as a,c as o,k as e,a as n}from"./chunks/framework.c5c8a48b.js";const w=JSON.parse('{"title":"绘制线段的能力","description":"","frontmatter":{},"headers":[],"relativePath":"2023/webGPU学习/hui4zhi4xian4duan4de0neng2li4.md","filePath":"2023/webGPU学习/hui4zhi4xian4duan4de0neng2li4.md","lastUpdated":null}'),i={name:"2023/webGPU学习/hui4zhi4xian4duan4de0neng2li4.md"},s=e("h1",{id:"绘制线段的能力",tabindex:"-1"},[n("绘制线段的能力 "),e("a",{class:"header-anchor",href:"#绘制线段的能力","aria-label":'Permalink to "绘制线段的能力"'},"​")],-1),l=e("p",null,"已经粗略的看过了three.js和orillusion的渲染源码，接下面要对cad需要的线段绘制能力进行性能测试。在three.js中，线段绘制使用new THREE.LineSegments，底层使用的是webgl中的gl.LINES绘制。在webgpu中，则是用渲染管线的 topology: 'line-list' 绘制线段。",-1),d=e("p",null,"现在我们绘制线段的能力已经有了，还需要创造一个进行平移和缩放的2D场景。这里要用到正交投影",-1),r=e("h3",{id:"平移场景",tabindex:"-1"},[n("平移场景 "),e("a",{class:"header-anchor",href:"#平移场景","aria-label":'Permalink to "平移场景"'},"​")],-1),c=e("p",null,"模型平移结束后，再次平移，还是会以初始位置开始进行平移，没有记录下来模型第一次平移后的坐标，所以这个时候需要引入相机投影！",-1),h=e("p",null,"正交投影和透视投影为什么用的是同一个lookAt方法？ 第20节：世界空间变换到观察空间，这里解释了lookAt的封装思路",-1),_=e("p",null,"不管是正交还是透视投影，都和观察矩阵没有关系，他们是在观察矩阵之后的投影操作！",-1),u=[s,l,d,r,c,h,_];function p(m,f,g,x,b,k){return a(),o("div",null,u)}const z=t(i,[["render",p]]);export{w as __pageData,z as default};
