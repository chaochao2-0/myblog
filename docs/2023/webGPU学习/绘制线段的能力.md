# 绘制线段的能力

已经粗略的看过了three.js和orillusion的渲染源码，接下面要对cad需要的线段绘制能力进行性能测试。在three.js中，线段绘制使用new THREE.LineSegments，底层使用的是webgl中的gl.LINES绘制。在webgpu中，则是用渲染管线的 topology: 'line-list' 绘制线段。

现在我们绘制线段的能力已经有了，还需要创造一个进行平移和缩放的2D场景。这里要用到正交投影


### 平移场景
模型平移结束后，再次平移，还是会以初始位置开始进行平移，没有记录下来模型第一次平移后的坐标，所以这个时候需要引入相机投影！


正交投影和透视投影为什么用的是同一个lookAt方法？
第20节：世界空间变换到观察空间，这里解释了lookAt的封装思路

不管是正交还是透视投影，都和观察矩阵没有关系，他们是在观察矩阵之后的投影操作！

webgpu下一步：
1，学习鼠标拾取的底层原理，做选中效果
2，学习如何将模型数据转化为webgpu可以使用的数据实现图纸的加载
3，关于手绘线的优化方案：使用贝塞尔曲线或柏林噪声来解决手绘线不平滑的问题
4，精度问题是否依然存在？精度问题导致的原因是js，应该还会存在
5，文字的绘制：可以参考Orillusion的实现（https://www.orillusion.com/guide/gui/textfield.html），源码路径：src\components\gui\uiComponents\UITextField.ts，使用 Bitmap Font，下载了它的字体文件，只有400k大小


批注的颜色和线宽需要去实现：
但是选择批注的辉光效果目前不是很好实现
而且线宽的调整也不是很好实现



鼠标拾取的原理：将摄像机原点与近裁剪平面的一点连起来，形成一条射线，射线如果穿过 视锥体中的距离近裁剪平面最近的模型，那么代表鼠标选中了该模型。

回去了学习顶点数据和片元数据共用缓冲区（已完成）

```ts
let nowTime = new Date().getTime()
let pointArr = []
const triangleNum = 1000
for (let i = 0; i < triangleNum; i++) {
    for(let j = 0; j < triangleNum; j++) {
        const distence = 1
        pointArr.push(
            distence * i, -distence * j, 0.0,
            distence * i, -distence * j + 0.5, 0.0,
            distence * i + 0.5, -distence * j, 0.0
        )
    }
}
const vertexArray = new Float32Array(pointArr)
console.log(new Date().getTime() - nowTime) // 735 这个时间大概是700毫秒左右
```

1，彻底弄懂鼠标拾取的原理，用webgpu实现出来
缓冲区拾取就是利用FBO（帧缓冲区）渲染另外一份顶点数据一样，但是顶点颜色是按照ID位计算成RGB值，这样就保证了每一个物体的颜色值都不一样，这样点击的时候获取到点击位置的RGB值，再位换算回ID值就可以知道点击到哪个物体了。缓冲区拾取是用空间（多一份数据）换时间（拾取快），另外由于缓冲区拾取不需要遍历模型，所以模型是可以做合模处理的。

https://segmentfault.com/a/1190000041361406

three缓冲区拾取步骤：
 - 准备好两份数据，一份渲染输出到屏幕，一份渲染到FBO，同时把每个物体的信息存起来
 - 创建一个webglRenderTarget()(FBO，不直接输出到屏幕)
 - 渲染FBO，通过获取到的颜色位换算回ID值，判断点击了哪个物体
 - 通过ID值获取到点击的物体的信息，在生成一个正方体套在点击物体外面，表示高亮
 - 最后正常渲染场景，输出到颜色缓冲区（屏幕）

 缓冲区拾取的原理是：利用FBO（帧缓冲区）渲染另外一份顶点数据一样，但是顶点颜色是按照ID位计算成RGB值，这样就保证了每一个物体的颜色值都不一样，这样点击的时候获取点击位置的RGB值，再位换算回ID值就可以知道点击到哪个物体了。缓冲区拾取是用空间（多一份数据）换时间（拾取快），另外由于缓冲区拾取不需要遍历模型，所以模型是可以做合模处理的。


2，将图纸正常加载出来并居中显示
移动相机的位置矩阵到模型的中心，然后调整正交投影的参数进行投影。
相机的位置矩阵移动意味着对模型的数据坐标x - 相机位置x;同理数据坐标y - 相机位置y

3，抽象出来图元对象来做数据处理，包括图元的显示和隐藏，都使用图元对象最终操作一个float32Array的数组来实现
我这样实现的话，图元的显示和隐藏就不可能像three一样通过对象的一个属性来实现显示和隐藏，three通过属性实现显示和隐藏的原理是什么？

4，如果所有内容都是一次性的绘制，如何进行内容填充？cad的图纸填充这个可以后面再考虑！
