# 测试
并发请求之前一直做的很少，没有一个很好的并发请求的概念。这次在CAD项目中，第一次感受到了并发请求的重要性。尤其在处理大文件，运用一些切片上传、并发请求的场景中，并发请求是必须要用的。

在CAD中，我这边的并发请求用的是Promise.all来处理，将CAD的各种需要请求的资源通过Promise来封装，然后用Promise.all来并发请求<br />![image.png](/images/avatar.jpg)

以上是我的并发请求实现思路，这种实现方式有一个问题就是：Promise.all的并发，它会等待所有请求都返回了才去处理逻辑。如果遇到一些比较复杂的场景，需要并发请求，并且需要保持一定的并发数量，比如有一百个请求，需要同时保持有十个请求在并发处理，响应一个，继续请求下一个。这种逻辑该如何进行处理和实现：

```
const arr = []
for (let i = 0; i < 100; i++) {
    arr.push(
        () =>
            new Promise((resolve) => {
                setTimeout(() => {
                    console.log('done', i)
                    resolve()
                }, 100 * i)
            })
    )
}

const parallelRun = () => {
    const runingTask = new Map()
    const inqueue = (totalTask, max) => {
        while (runingTask.size < max && totalTask.length) {
            const newTask = totalTask.shift()
            const tempName = totalTask.length
            runingTask.set(tempName, newTask)
            newTask().finally(() => {
                runingTask.delete(tempName)
                inqueue(totalTask, max)
            })
        }
    }
    return inqueue
}

parallelRun()(arr, 6)

```
还有一个使用Promise进行并发请求处理的一个库：p-limit<br />[https://github.com/sindresorhus/p-limit](https://github.com/sindresorhus/p-limit)
