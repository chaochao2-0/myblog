# 嘉立创

## 顶点着色器是不是只有顶点信息？法线这些如何获取？
不是的，除了顶点信息，顶点着色器还可以访问其他类型的数据，如：法线、纹理坐标等。
## webgl的渲染管线它的流程是怎样的？
- 顶点着色器阶段（Vertex Shader Stage）：在这个阶段，输入的顶点数据会被处理。顶点着色器会对每个顶点执行一系列运算，例如计算变换后的顶点位置、法线、纹理坐标等等。这个阶段的输出会被送到下一个阶段进行处理。
- 图元装配阶段（Primitive Assembly Stage）：这个阶段会将顶点着色器输出的顶点连接起来，形成几何图形，例如点、线段、三角形等。这个阶段的输出会被送到下一个阶段进行处理。
- 光栅化阶段（Rasterization Stage）：在这个阶段，图元会被分解成一组更小的像素，也就是所谓的片元（fragment）。每个片元都有自己的属性，例如颜色、深度值等，这些属性会根据光栅化的结果进行计算。
- 片元着色器阶段（Fragment Shader Stage）：在这个阶段，片元的属性会被处理。片元着色器会执行一系列运算，例如计算最终的颜色、混合多个纹理、进行雾效处理等等。这个阶段的输出会被送到下一个阶段进行处理。
- 输出合并阶段（Output Merging Stage）：在这个阶段，所有的片元会被送入帧缓冲区，最终生成显示在屏幕上的图像。 需要注意的是，以上只是一个通用的渲染管线流程，具体的实现可能会有所不同。此外，不同的WebGL API版本可能也会有一些差异。

## gltf格式的数据格式是怎样的？如何优化？


## Node的子进程有哪些方法？
Node 提供了 child_process 模块来创建子进程，方法有：

exec - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式一次性返回。exec方法会从子进程中返回一个完整的buffer。默认情况下，这个buffer的大小应该是200k。如果子进程返回的数据大小超过了200k，程序将会崩溃，同时显示错误信息“Error：maxBuffer exceeded”。你可以通过在exec的可选项中设置一个更大的buffer体积来解决这个问题，但是你不应该这样做，因为exec本来就不是用来返回很多数据的方法。

spawn - child_process.spawn 使用指定的命令行参数创建新进程。spawn 会返回一个带有stdout和stderr流的对象。你可以通过stdout流来读取子进程返回给Node.js的数据。stdout拥有’data’,’end’以及一般流所具有的事件。当你想要子进程返回大量数据给Node时，比如说图像处理，读取二进制数据等等，你最好使用spawn方法。

fork - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(‘./son.js’) 相当于 spawn(‘node’, [‘./son.js’]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。


## 字节外包面试
如何快速通过debugger的方式去找到某种效果的实现方式？
带着问题去调试，在调试的过程看源码

- 如何实现一个函数继承另一个函数
- 如何用promise基于一个方法封装callback函数,封装成.then的方式访问数据
- 如何实现数组去重，es5和es6分别怎么实现，es5实现的算法时间复杂度和空间复杂度是多少
```js
// 我的答案:
const aa = (arr) => {
    let newArr = []
    arr.forEach(item => {
        const index = newArr.findIndex(data => data === item)
        if (index === -1) {
            newArr.push(item)
        }
    })
    return newArr
}
```
- 鼠标点击焦点，我这边点击，你那边会同步显示谁点击在什么位置，这个效果是如何实现的？
- vue模板编译成AST后，最后又变成了什么形式，最终在浏览器中渲染成了html

## 字节二面
- 对webpack、vite的配置有些什么理解
- promise.race的实现
- 数组的reduce方法实现
- ts的使用熟练度怎么样
- node的进程使用

